# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

m4_changequote(`<!', `!>')

"""
@file knn.py_in

@brief knn: Driver functions

@namespace knn

@brief knn: Driver functions
"""

import plpy
from utilities.validate_args import table_exists
from utilities.validate_args import table_is_empty
from utilities.validate_args import columns_exist_in_table
from utilities.validate_args import columns_exist_in_table
from utilities.validate_args import is_col_array
from utilities.validate_args import array_col_has_no_null
from utilities.validate_args import get_cols_and_types
from utilities.utilities import unique_string
from utilities.control import MinWarning



def knn_validate_src(schema_madlib, point_source, point_column_name, label_column_name,
    test_source, test_column_name, id_column_name, output_table, operation, k, **kwargs):
    if not operation or operation not in ['c', 'r']:
        plpy.error("kNN Error: operation='{0}' is an invalid value, has to be 'r' for regression OR 'c' for classification.".format(operation))
    if not point_source:
        plpy.error("kNN Error: Invalid training table name.")
    if not table_exists(point_source):
        plpy.error("kNN Error: Training table '{0}' does not exist.".format(point_source))
    if table_is_empty(point_source):
        plpy.error("kNN Error: Training table '{0}' is empty.".format(point_source))

    if not test_source:
        plpy.error("kNN Error: Invalid test table name.")
    if not table_exists(test_source):
        plpy.error("kNN Error: Test table '{0}' does not exist.".format(test_source))
    if table_is_empty(test_source):
        plpy.error("kNN Error: Test table '{0}' is empty.".format(test_source))

    for c in (label_column_name, point_column_name):
        if not c:
            plpy.error("kNN Error: Invalid column name in training table.")
        if not columns_exist_in_table(point_source, [c]):
            plpy.error("kNN Error: " + \
                    "Column '{0}' does not exist in {1}.".format(c, point_source))

    for c in (test_column_name, id_column_name):
        if not c:
            plpy.error("kNN Error: Invalid column name in test table.")
        if not columns_exist_in_table(test_source, [c]):
            plpy.error("kNN Error: " + \
                    "Column '{0}' does not exist in {1}.".format(c, test_source))

    if not is_col_array(point_source, point_column_name):
        plpy.error("kNN Error: " + \
                    "Feature column '{0}' in train table is not an array.".format(point_column_name))
    if not is_col_array(test_source, test_column_name):
        plpy.error("kNN Error: " + \
                    "Feature column '{0}' in test table is not an array.".format(test_column_name))

    if not array_col_has_no_null(point_source, point_column_name):
        plpy.error("kNN Error: " + \
                    "Feature column '{0}' in train table has some NULL values.".format(point_column_name))
    if not array_col_has_no_null(test_source, test_column_name):
        plpy.error("kNN Error: " + \
                    "Feature column '{0}' in test table has some NULL values.".format(test_column_name))

    if not output_table:
        plpy.error("kNN Error: Invalid output table name")
    if table_exists(output_table):
        plpy.error("kNN Error: Table '{0}' already exists, cannot use it as output table.".format(output_table))

    if k is None:
        k = 1
    if k<=0:
        plpy.error("kNN Error: k='{0}' is an invalid value, must be greater than 0.".format(k))
    bound = plpy.execute("""SELECT {k} <= count(*)
            AS bound FROM {tbl}""".format(k=k,
            point_column_name=point_column_name, tbl=point_source))[0]['bound']
    if not bound:
        plpy.error("kNN Error: " + \
                "k='{0}' is greater than number of rows in training table.".format(k))

    colTypesList = get_cols_and_types(point_source)
    colType = ''
    for type in colTypesList:
        if type[0] == label_column_name:
            colType = type[1]
            break
    if colType not in ['INTEGER','integer','double precision','DOUBLE PRECISION','float','FLOAT','boolean','BOOLEAN']:
        plpy.error("kNN Error: " + \
                    "Data type '{0}' is not a valid type for column '{1}' in table '{2}'.".format(colType, label_column_name, point_source))

    colTypesTestList = get_cols_and_types(test_source)
    colType = ''
    for type in colTypesTestList:
        if type[0] == id_column_name:
            colType = type[1]
            break
    if colType not in ['INTEGER','integer']:
        plpy.error("kNN Error: " + \
                    "Data type '{0}' is not a valid type for column '{1}' in table '{2}'.".format(colType, id_column_name, test_source))
    return k





def knn(schema_madlib, point_source, point_column_name, label_column_name,
    test_source, test_column_name, id_column_name, output_table, operation, k):

    """
        KNN function to find the K Nearest neighbours
        Args:
            @param schema_madlib       Name of the Madlib Schema
            @param point_source        Training data table
            @param point_column_name   Name of the column with training data points.
            @param label_column_name   Name of the column with labels/values of training data points.
            @param test_source         Name of the table containing the test data points.
            @param test_column_name    Name of the column with testing data points.
            @param id_column_name      Name of the column having ids of data points in test data table.
            @param output_table        Name of the table to store final results.
            @param operation           Flag for the operation: 'c' for classification and 'r' for regression
            @param k                   default: 1. Number of nearest neighbors to consider
        Returns:
            VARCHAR                     Name of the output table.
    """
    with MinWarning('warning'):
        k_val = knn_validate_src(schema_madlib, point_source, point_column_name,
                    label_column_name, test_source,
                    test_column_name, id_column_name,
                    output_table, operation, k)


        plpy.execute("SELECT {schema_madlib}.create_schema_pg_temp()".format(schema_madlib=schema_madlib))
        x_temp_table = unique_string(desp='x_temp_table')
        y_temp_table = unique_string(desp='y_temp_table')
        label_column_name_unique = unique_string(desp='label_column_name_unique')
        test_id = unique_string(desp='test_id')

        convert_boolean_to_int = ''
        isClassification = False
        if operation == 'c':
            convert_boolean_to_int = '::INTEGER'
            isClassification = True
        madlib_knn_interm = unique_string(desp='madlib_knn_interm')
        plpy.execute("""DROP TABLE IF EXISTS pg_temp.{madlib_knn_interm}""".format(**locals()))
        plpy.execute(
        """
        CREATE TEMP TABLE pg_temp.{madlib_knn_interm} AS SELECT * FROM
            (
            SELECT row_number() over (partition by {test_id}  order by dist) AS r , {x_temp_table}.*
                FROM
                (
                    SELECT test.{id_column_name} AS  {test_id} , {schema_madlib}.squared_dist_norm2(train.{point_column_name} ,test.{test_column_name}) AS dist, train.{label_column_name} {convert_boolean_to_int} AS {label_column_name_unique}
                        FROM  {point_source} AS train, {test_source}  AS test
                    ) {x_temp_table}
                ){y_temp_table}
            WHERE {y_temp_table}.r <= {k_val}""".format(**locals()))

        if isClassification:
            plpy.execute(
            """
            CREATE TABLE {output_table} AS
            SELECT {test_id} AS id, {test_column_name} , {schema_madlib}.mode({label_column_name_unique}) AS prediction
            FROM pg_temp.{madlib_knn_interm} join  {test_source}  ON  {test_id} = {id_column_name}
            GROUP BY {test_id}  ,  {test_column_name}""".format(**locals()))
        else:
            plpy.execute(
            """
            CREATE TABLE  {output_table} AS
            SELECT  {test_id}   AS id, {test_column_name} , avg( {label_column_name_unique}  ) AS prediction
            FROM
                pg_temp.{madlib_knn_interm} join {test_source}  on {test_id}  ={id_column_name}
            GROUP BY {test_id} ,  {test_column_name}
            ORDER BY {test_id}""".format(**locals()))

        if isClassification:
            returnstring = 'The classification results have been written to output table '+ output_table
        else:
            returnstring = 'The regression results have been written to output table '+ output_table

        plpy.execute("""DROP TABLE pg_temp.{madlib_knn_interm}""".format(**locals()))

        return returnstring
