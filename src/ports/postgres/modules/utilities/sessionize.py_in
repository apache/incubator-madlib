# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

import plpy
import string
import re

from control import MinWarning
from utilities import unique_string, _assert, split_quoted_delimited_str
from validate_args import get_cols
from validate_args import input_tbl_valid, output_tbl_valid, is_var_valid

m4_changequote(`<!', `!>')

def sessionize(schema_madlib, source_table, output_table, partition_expr,
                time_stamp, max_time, output_cols=None, create_view=None, **kwargs):
    """
        Perform sessionization over a sequence of rows.

        Args:
        @param schema_madlib: str, Name of the MADlib schema
        @param source_table: str, Name of the input table/view
        @param output_table: str, Name of the table to store result
        @param partition_expr: str, Expression to partition (group) the input data
        @param time_stamp: str, The time stamp column name that is used for sessionization calculation
        @param max_time: interval, Delta time between subsequent events to define a session
        @param output_cols: str, list of columns the output table/view must contain (default '*'):
                        * - all columns in the input table, and a new session ID column
                        'a,b,c,...' -  a comma separated list of column names/expressions to be projected, along with a new session ID column
        @param create_view: boolean, indicates if the output is a view or a table with name specified by output_table (default TRUE)
                        TRUE - create view
                        FALSE - materialize results into a table
    """
    with MinWarning("error"):
        _validate(source_table, output_table, partition_expr, time_stamp, max_time)
        table_or_view = 'VIEW' if create_view or create_view is None else 'TABLE'
        output_cols_to_project = '*' if output_cols is None else output_cols

        cols_to_project = get_columns_to_project_str(schema_madlib, source_table, output_cols_to_project)
        session_id = 'session_id' if not is_var_valid(source_table, 'session_id') else unique_string('session_id')

        # Create temp column names for intermediate columns.
        new_partition = unique_string('new_partition')
        new_session = unique_string('new_session')

        plpy.execute("""
                CREATE {table_or_view} {output_table} AS
                    SELECT
                        {cols_to_project},
                        CASE WHEN {time_stamp} IS NOT NULL
                        THEN SUM(CASE WHEN {new_partition} OR {new_session} THEN 1 END) OVER (PARTITION BY {partition_expr} ORDER BY {time_stamp}) END AS {session_id}
                    FROM (
                        SELECT *,
                            ROW_NUMBER() OVER (w) = 1 AND {time_stamp} IS NOT NULL AS {new_partition},
                            ({time_stamp}-LAG({time_stamp}, 1) OVER (w)) > '{max_time}'::INTERVAL AS {new_session}
                        FROM {source_table} WINDOW w AS (PARTITION BY {partition_expr} ORDER BY {time_stamp})
                        ) a
            """.format(**locals()))

def get_columns_to_project_str(schema_madlib, source_table, output_cols):
    """
        This method creates a string that can be used in the SQL statement to project the columns 
        specified in the output_cols parameter.
        Args:
        @param schema_madlib: str, Name of the MADlib schema
        @param source_table: str, Name of the input table/view
        @param output_cols: str, comma separated string specifying coulumns/expressions to project

        If an element in output_cols is a column name from the input table, it is maintained as is.
        But, if it is an expression, the expression is renamed using a quoted string.

        Example:
        output_cols = 'user_name, "user id"<100", revenue>20'
        Return value:
        'user_name, "user id"<100 AS "user id<100", revenue>20 AS "revenue>20"'

        Return:
        a string to be used in the SQL statement
    """
    table_columns_list = get_cols(source_table, schema_madlib)
    if output_cols.strip() == '*':
        output_cols_str = get_cols_str(table_columns_list)
    else:
        output_cols_list, output_cols_names = get_columns_from_expression(output_cols, table_columns_list)
        _validate_output_cols(source_table, output_cols_list)
        output_cols_str = ', '.join([output_cols_names[i] if output_cols_list[i] == '*' else output_cols_list[i] + ' AS ' + output_cols_names[i] 
            for i in range(len(output_cols_list))])
    return output_cols_str

def create_column_name_from_expression(col_name, table_columns_list):
    """
    This method creates a new name for an expression, which is used as the column name for that expression
    when materialized into the result table/view.

    Args:
    @param: col_name: str, the expression.
    @param: table_columns_list: list, contains all the existing columns names of the input table

    All existing quotes in col_name, if any, are removed. The string thus obtained is then quoted. If this quoted
    string is already an element in table_columns_list, then a unique string is created as the column name corresopnding
    to col_name.

    Example:
    1) col_name= "user id"<100
    Return value: "user id<100"
    2) col_name = revenue>20
    Return value: "revenue>20"

    Return:
    A string which represents the column name corresponding to the expression specified in col_name
    """
    if col_name == '*':
        return get_cols_str(table_columns_list)
    else:
        # Column name cannot have more than one pair of quotes in it. Removing any existing quotes,
        # and then quoting the new string obtained.
        col_name = col_name.replace('"','')
        col_name = '"'+col_name + '"'
        # If the col_name thus obtained is the same as an existing column name in the input table,
        # return a unique string, else return col_name
        if col_name in table_columns_list:
            return unique_string(col_name)
        else:
            return col_name

def get_cols_str(table_columns_list):
    return ', '.join([i for i in table_columns_list])

def get_columns_from_expression(output_cols, table_columns_list):
    """
    output_cols is a comma separated string of expressions. This function creates a list consisting of the elements (expressions)
    in output_cols, and another list containing the corresponding name for each element (expression).
    """
    cols_list = split_quoted_delimited_str(output_cols)
    # If an entry in cols_list is an existing column name in the input table, keep the name as is. If NOT,
    # create a new name for the entry (expression).
    cols_names = [i if i in table_columns_list else create_column_name_from_expression(i, table_columns_list) for i in cols_list]
    return cols_list, cols_names

def _validate_output_cols(source_table, output_cols_list):
    null_regex = re.compile('^null$', re.IGNORECASE)
    for col in output_cols_list:
        _assert(is_var_valid(source_table, col), "Sessionization error: Invalid output column name: " + col)
        _assert(True if null_regex.search(col) is None else False, "Sessionization error: Output column name cannot be " + col)

def _validate(source_table, output_table, partition_expr, time_stamp, max_time):
    input_tbl_valid(source_table, 'Sessionization')
    output_tbl_valid(output_table, 'Sessionization')
    # ensure the expressions are not None or empty strings
    _assert(partition_expr, "Sessionization error: Invalid partition expression")
    _assert(time_stamp, "Sessionization error: Invalid time stamp column")
    _assert(max_time, "Sessionization error: Invalid max time value")
    # ensure the partition/order expression can actually be used
    _assert(is_var_valid(source_table, partition_expr, time_stamp),
            "Sessionization error: Invalid partition expression or time stamp column name")

def sessionize_help_message(schema_madlib, message, **kwargs):
    """
    Help message for sessionize function
    """
    help_string = """
        ------------------------------------------------------------
                                SUMMARY
        ------------------------------------------------------------
        Functionality: Sessionize

        The goal of the MADlib sessionize function is to perform sessionization over
        a time-series based data. 

        ------------------------------------------------------------
                                USAGE
        ------------------------------------------------------------
        SELECT {schema_madlib}.sessionize(
            'source_table',     -- str, Name of the table
            'output_table',     -- str, Table name to store the Sessionization results
            'partition_expr',   -- str, Partition expression to group the data table
            'time_stamp'        -- str, The time stamp column name that is used for sessionization calculation
            'max_time'          -- str, Delta time between subsequent events to define a session
            'output_cols'       -- str, an optional comma separated list of columns to be projected in the output table/view (default *)
            'create_view'       -- boolean, optional parameter to specify if output is a view or materilized to a table (default True)
        );

        ------------------------------------------------------------
                                EXAMPLE
        ------------------------------------------------------------
        - Create an input data set

        DROP TABLE IF EXISTS ecommerce_sessionize;
        CREATE TABLE eventlog (event_timestamp TIMESTAMP,
                    user_id INT,
                    old_session_id INT,
                    page TEXT,
                    revenue FLOAT,
                    row INT);
        COPY ecommerce_sessionize (event_timestamp, user_id, old_session_id,
                                   page, revenue, row) FROM stdin delimiter '|';
        '04/15/2015 01:03:0.5'|100821|100|'LANDING'|0|1
        '04/15/2015 01:03:50'|100821|100|'WINE'|0|1
        '04/15/2015 01:04:10'|100821|100|'CHECKOUT'|39|1
        '04/15/2015 01:04:15'|100821|101|'WINE'|0|1
        '04/15/2015 01:05:00'|100821|100|'WINE'|0|1
        '04/15/2015 01:07:00'|100821|100|'CHECKOUT'|39|1
        '04/15/2015 02:06:00'|100821|101|'WINE'|0|1
        '04/15/2015 02:06:10'|100821|101|'WINE'|0|1
        '04/15/2015 02:06:20'|100821|101|'WINE'|0|1
        '04/15/2015 02:06:30'|100821|101|'WINE'|0|1
        '04/15/2015 02:07:00'|100821|101|'WINE'|0|1
        '04/15/2015 01:15:00'|101121|102|'LANDING'|0|1
        '04/15/2015 01:16:00'|101121|102|'WINE'|0|1
        '04/15/2015 01:18:00'|101121|102|'CHECKOUT'|15|1
        '04/15/2015 01:19:00'|101121|102|'LANDING'|0|1
        '04/15/2015 01:21:00'|101121|102|'HELP'|0|1
        NULL|101121|102|'LANDING'|0|1
        NULL|101121|102|'HELP'|0|1
        '04/15/2015 01:24:00'|101121|102|'WINE'|0|1
        '04/15/2015 01:26:00'|101121|102|'CHECKOUT'|23|1
        '04/15/2015 02:21:00'|101121|102|'HELP'|0|1
        '04/15/2015 02:24:00'|101121|102|'WINE'|0|1
        '04/15/2015 02:26:00'|101121|102|'CHECKOUT'|23|1
        '04/15/2015 02:15:00'|101331|103|'LANDING'|0|1
        '04/15/2015 02:16:00'|101331|103|'WINE'|0|1
        '04/15/2015 02:18:00'|101331|103|'HELP'|0|1
        '04/15/2015 02:20:00'|101331|103|'WINE'|0|1
        '04/15/2015 02:21:00'|101331|103|'CHECKOUT'|16|1
        '04/15/2015 02:22:00'|101443|104|'BEER'|0|1
        '04/15/2015 02:25:00'|101443|104|'CHECKOUT'|12|1
        '04/15/2015 02:29:00'|101881|105|'LANDING'|0|1
        '04/15/2015 02:30:00'|101881|105|'BEER'|0|1
        '04/15/2015 01:05:00'|102201|106|'LANDING'|0|1
        '04/15/2015 01:06:00'|102201|106|'HELP'|0|1
        '04/15/2015 01:09:00'|102201|106|'LANDING'|0|1
        '04/15/2015 02:15:00'|102201|107|'WINE'|0|1
        '04/15/2015 02:16:00'|102201|107|'BEER'|0|1
        '04/15/2015 02:17:00'|102201|107|'WINE'|0|1
        '04/15/2015 02:18:00'|102871|108|'BEER'|0|1
        '04/15/2015 02:19:00'|102871|108|'WINE'|0|1
        '04/15/2015 02:22:00'|102871|108|'CHECKOUT'|21|1
        '04/15/2015 02:25:00'|102871|108|'LANDING'|0|1
        NULL|103711|109|'BEER'|0|1
        NULL|103711|109|'LANDING'|0|1
        NULL|103711|109|'WINE'|0|1
        '04/15/2016 02:17:00'|103711|109|'BEER'|0|1
        '04/15/2016 02:18:00'|103711|109|'LANDING'|0|1
        '04/15/2016 02:19:00'|103711|109|'WINE'|0|1
        \.

        - Sessionize the table for each user_id, and obtain only the user_id, with partition expression, 
        event_timestamp and session_id:

        SELECT {schema_madlib}.sessionize(
         'eventlog',            -- Name of input table
         'sessionize_output',   -- Table name to store sessionized results
         'user_id',             -- Partition input table by session
         'event_timestamp',     -- Order partitions in input table by time
         '0:3:0'                -- Events within a window of this time unit (180 seconds) must be in the same session
         );

        - View the output table containing the session IDs:

        SELECT * FROM sessionize_output;

        DROP VIEW sessionize_output;

        - Sessionize the table for each user_id, and materialize all columns from source table into an output table:
        SELECT {schema_madlib}.sessionize(
         'eventlog',                -- Name of input table
         'sessionize_output',       -- Table name to store sessionized results
         'user_id',                 -- Partition input table by session
         'event_timestamp',         -- Order partitions in input table by time
         '180'                      -- Events within a window of this time unit (180 seconds) must be in the same session
         'user_id, event_timestamp' -- Preseve only user_id and event_timestamp columns, along with the session id column
         'false'                    -- Materialize results into a table, and not a view
         );
        
        - View the output table containing the session IDs:

        SELECT eventlog.*, sessionize_output.session_id FROM eventlog INNER JOIN sessionize_output ON 
        (eventlog.user_id=sessionize_output.user_id AND eventlog.event_timestamp=sessionize_output.event_timestamp);
        
        DROP TABLE sessionize_output;
    """

    return help_string.format(schema_madlib=schema_madlib)
