# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Pivoting
# The goal of the MADlib pivot function is to provide a data summarization tool
# that can do basic OLAP type operations on data stored in one table and output
# the summarized data to a second table.  Typical operations are count, average,
# min, max and standard deviation, however user defined aggregates (UDAs) are
# also be allowed.

# Please refer to the pivot.sql_in file for the documentation

"""
@file pivot.py_in

"""

import plpy
import itertools
from control import MinWarning
from utilities import _assert
from utilities import split_quoted_delimited_str
from utilities import strip_end_quotes
from utilities import extract_keyvalue_params
from validate_args import table_exists
from validate_args import columns_exist_in_table
from validate_args import table_is_empty
from validate_args import _get_table_schema_names
from validate_args import get_first_schema

m4_changequote(`<!', `!>')

def pivot(schema_madlib, source_table, out_table, index, pivot_cols,
    pivot_values, aggregate_func=None, fill_value=None, keep_null=False,
    output_col_dictionary=False, **kwargs):
    """
    Helper function that can be used to pivot tables
    Args:
        @param source_table     The original data table
        @param out_table        The output table that contains the dummy
                                variable columns
        @param index            The index columns to group by the records by
        @param pivot_cols       The columns to pivot the table
        @param pivot_values     The value columns to be summarized in the
                                pivoted table
        @param aggregate_func   The aggregate function to be applied to the
                                values
        @param fill_value       If specified, determines how to fill NULL
                                values resulting from pivot operation
        @param keep_null        The flag for determining how to handle NULL
                                values in pivot columns
    """
    """
    Assume we have the following table
        pivset( id INTEGER, piv FLOAT8, val FLOAT8 )
    where the piv column has 3 distinct values (10, 20 and 30).
    If the pivot function call is :
        SELECT madlib.pivot('pivset', 'pivout', 'id', 'piv', 'val');
    We want to construct the following sql code to pivot the table.
        CREATE TABLE pivout AS (SELECT id,
        avg(CASE WHEN "piv" = '10' THEN val ELSE NULL END ) as "val_avg_piv_10",
        avg(CASE WHEN "piv" = '20' THEN val ELSE NULL END ) as "val_avg_piv_20",
        avg(CASE WHEN "piv" = '30' THEN val ELSE NULL END ) as "val_avg_piv_30"
        FROM pivset GROUP BY id ORDER BY id)

    """

    # If there are more than 1000 columns for the output table, we give a
    # warning as it might give an error.
    MAX_OUTPUT_COLUMN_COUNT = 1000

    # If a column name has more than 63 characters it gets trimmed automaticly,
    # which may cause an exception. We enable the output dictionary in this case
    MAX_COLUMN_LENGTH = 63

    indices = split_quoted_delimited_str(index)
    pcols = split_quoted_delimited_str(pivot_cols)
    pvals = split_quoted_delimited_str(pivot_values)
    validate_pivot_coding(source_table, out_table, indices, pcols, pvals)

    # Strip end quotes from pivot columns
    pcols = [strip_end_quotes(pcol.strip()) for pcol in pcols]
    pvals = [strip_end_quotes(pval.strip()) for pval in pvals]

    # Parse the aggregate_func as a dictionary
    try:
        param_types = dict.fromkeys(pvals, list)
        agg_dict = extract_keyvalue_params(aggregate_func,param_types)
    except KeyError, e:
        with MinWarning("warning"):
            plpy.warning("Pivot: Not all columns from '{aggregate_func}'"
            " present in '{pivot_values}'".format(**locals()))
            raise

    # If the dictionary is empty, parse it as a list
    agg_set = split_quoted_delimited_str(aggregate_func) if not agg_dict else []

    # __madlib_pivot_def_agg__ denotes the aggregate function(s) if the user
    # does not specify a value: aggregate dictionary
    # If no aggregates are given, set average as default
    agg_dict['__madlib_pivot_def_agg__'] = ['avg'] if not agg_set else agg_set

    # Find the distinct values of pivot_cols
    # Note that the distinct values are appended in order of users list
    # This ordering is important when we access pivot_comb entries
    array_agg_str = ', '.join("array_agg(DISTINCT {pcol}) AS {pcol}_values".
        format(pcol=pcol) for pcol in pcols)

    null_str = ""
    if keep_null:
        # Create an additional column for every pivot column
        # If there is a null value, this column will get True
        null_str = ","+', '.join(
            "bool_or(CASE WHEN {pcol} IS NULL THEN True END)"
            "AS {pcol}_isnull".format(pcol=pcol) for pcol in pcols)

    distinct_values = plpy.execute("SELECT {0} {1} FROM {2}".
        format(array_agg_str, null_str, source_table))

    # Collect the distinct values for every pivot column
    pcol_distinct_values = {}
    pcol_max_length = 0
    for pcol in pcols:
        # Read the distinct values for this pcol
        pcol_tmp = [item for item in distinct_values[0][pcol+"_values"]]
        # Remove null values if keep null is not true
        if not keep_null:
            pcol_tmp = [x for x in pcol_tmp if x is not None]
        elif distinct_values[0][pcol+"_isnull"] and None not in pcol_tmp:
            pcol_tmp.append(None)

        pcol_distinct_values[pcol]=sorted(pcol_tmp)
        # Max length of the string that pcol values can create +
        # length of pcol + 1 (for _ character)
        pcol_max_length+=max([len(str(item)) for item in pcol_tmp])+len(pcol)+1

    # Create the combination of every possible pivot column
    # Assume piv and piv2 are pivot columns. piv=(1,2) and piv2=(3,4,5)
    # pivot_comb = ((1,3),(1,4),(1,5),(2,3),(2,4),(2,5))
    pivot_comb = list(itertools.product(*([pcol_distinct_values[pcol]
        for pcol in pcols])))
    #Prepare the wrapper for fill value
    fill_str_begin = ""
    fill_str_end = ""
    if fill_value is not None:
        fill_str_begin = " COALESCE("
        fill_str_end = ", "+fill_value+" ) "

    # Check the max possible length of a output column name
    # If it is over 63 (psql upper limit) create table lookup
    for pval in pvals:

        col_name_len = pcol_max_length+len(pval)+1
        try:
            # If user specifies a list of aggregates for a value column
            # Every value column has to have an entry
            agg_func = agg_dict[pval] if len(agg_dict) > 1 else \
                       agg_dict['__madlib_pivot_def_agg__']
        except KeyError, e:
            with MinWarning("warning"):
                plpy.warning("Pivot: Pivot column '{pval}' does not have an "
                "assigned aggregate function in '{aggregate_func}'".
                    format(**locals()))
                raise

        col_name_len += max([len(item) for item in agg_func])+1
        if col_name_len > MAX_COLUMN_LENGTH:
            with MinWarning("warning"):
                plpy.warning("Pivot: Output columns are renamed to keep them "
                    "under 63 characters. Please refer to "
                    "{source_table}_dictionary for the original names.")
            output_col_dictionary = True

    # Create the output dictionary if needed
    if output_col_dictionary:
        out_dict = out_table+"_dictionary"
        _assert(not table_exists(out_dict),
                "Pivot: Output dictionary table already exists!")
        # Collect the types for pivot columns
        types_str = ["SELECT "]
        types_str.append(','.join("pg_typeof(\"{pcol}\") as {pcol}_type".
            format(pcol=pcol) for pcol in pcols))
        types_str.append(" FROM {source_table} LIMIT 1".format(**locals()))
        pcol_types = plpy.execute(''.join(types_str))

        # Create the empty dictionary table
        dict_str = ["CREATE TABLE "+out_dict+" ( "
            " __pivot_cid__ VARCHAR, pval VARCHAR, agg VARCHAR "]
        for pcol in pcols:
            dict_str.append(", {pcol} {pcol_type} ".
                format(pcol=pcol, pcol_type=pcol_types[0][pcol+"_type"]))
        dict_str.append(", col_name VARCHAR)")

        plpy.execute(''.join(dict_str))
        insert_str_begin = "INSERT INTO "+out_dict +" VALUES "
        insert_str = []
        insert_str_mid = []
        # Counter for the new output column names
        dict_counter = -1

    sql_list = ["CREATE TABLE " + out_table + " AS (SELECT " + index]

    # For every value column pval
    for pval in pvals:

        # If this pval has an entry in the dictionary use the assigned
        # aggregate function, otherwise use the default
        agg_func = agg_dict[pval] if len(agg_dict) > 1 else \
            agg_dict['__madlib_pivot_def_agg__']

        for agg in agg_func:

            # For every pivot value combination
            for comb in pivot_comb:

                pivot_str_begin=[]
                pivot_str_end=["\"{pval}_{agg}".format(pval=pval,agg=agg)]

                if output_col_dictionary:
                    dict_counter += 1
                    # Prepare the entry for the dictionary
                    insert_str=["(\'__p_{dict_counter}__\', \'{pval}\', "
                        "\'{agg}\' ".format(
                            dict_counter=dict_counter,
                            pval=pval, agg=agg)]

                # For every pivot column in a given combination
                for counter, pcol in enumerate(pcols):
                    # If we encounter a NULL value that means it is not filtered
                    # because of keep_null. Use "IS NULL" for comparison
                    if comb[counter] is None:
                        pivot_str_begin.append(" \"{pcol}\" IS NULL".
                            format(pcol=pcol))
                        # Naming the output column
                        pivot_str_end.append("_{pcol}_null".
                            format(pcol=pcol))
                    else:
                        pivot_str_begin.append(" \"{pcol}\" = '{value}'".
                            format(pcol=pcol, value = comb[counter]))
                        pivot_str_end.append("_{pcol}_{value}".
                            format(pcol=pcol, value = comb[counter]))

                    # Collect pcol values for the dict
                    if output_col_dictionary:
                        insert_str.append("{value}".format(value=comb[counter]
                            if comb[counter] is not None else "NULL"))
                pivot_str_end.append("\"")

                if output_col_dictionary:
                    # Store the whole string in case some user wants it
                    insert_str.append("\'{column_name}\')".
                        format(column_name=''.join(pivot_str_end)))

                    insert_str_mid.append( ', '.join(insert_str) )
                    # Replace the column name
                    pivot_str_end = ["__p_"+str(dict_counter)+"__"]

                    insert_sql = insert_str_begin + ', '.join(insert_str_mid)
                # Collecting the whole sql query
                # Please refer to the earlier comment for a sample output
                pivot_str=("{fill_str_begin} {agg}(CASE WHEN {pivot_begin}"
                " THEN {pval} END) {fill_str_end} as {pivot_end}".
                format(fill_str_begin=fill_str_begin,
                       fill_str_end=fill_str_end,
                       pval=pval, agg=agg,
                       pivot_begin=' AND '.join(pivot_str_begin),
                       pivot_end=''.join(pivot_str_end)))
                sql_list.append(","+pivot_str)



    sql_list.append(" FROM " + source_table +
                    " GROUP BY " + index + ") ")
    if output_col_dictionary:
        plpy.execute(''.join(insert_sql))
    try:
        plpy.execute(''.join(sql_list))
    except plpy.SPIError:
        # Warn user if the number of columns is over 1000 for the output table
        with MinWarning("warning"):

            # The column options from value columns and aggregates
            # If there is a dict. of aggregates count them
            if len(agg_dict) > 1:
                col_va_coef=sum([len(item) for item in agg_dict.values()]) - 1
            # If there is a list of aggregates
            # multiply the number of aggregates with the number of value columns
            else:
                col_va_coef=len(agg_dict['__madlib_pivot_def_agg__'])*len(pvals)

            # Multiply the va coef. with the number of pivot combinations
            if (col_va_coef*len(pivot_comb)) > MAX_OUTPUT_COLUMN_COUNT:
                plpy.warning("Pivot: Too many distinct values for pivoting! "
                    "The execution may fail due to too many columns in the "
                    "output table.")
        raise

    return None
#------------------------------------------------------------------------------

def validate_pivot_coding(source_table, out_table, indices, pivs, vals):
    """
    Args:
        @param source_table The original data table
        @param out_table    The output table that will contain dummy columns
        @param indices      An array of index column names
        @param cols         An array of categorical column names
    """
    _assert(out_table and
            out_table.strip().lower() not in ('null', ''),
            "Pivot: Invalid output table name!")
    _assert(not table_exists(out_table),
            "Pivot: Output table already exists!")
    _assert(source_table and source_table.strip().lower() not in ('null', ''),
            "Pivot: Invalid data table name!")
    _assert(table_exists(source_table),
            "Pivot: Data table ({0}) is missing!". format(source_table))
    _assert(not table_is_empty(source_table),
            "Pivot: Data table ({0}) is empty!". format(source_table))

    _assert(indices and indices not in ('null', ''),
            "Pivot: Invalid index column!")
    _assert(pivs and pivs not in ('null', ''),
            "Pivot: Invalid pivot column!")
    _assert(vals and vals not in ('null', ''),
            "Pivot: Invalid value column!")

    _assert(columns_exist_in_table(source_table, indices),
            "Pivot: Not all columns from {0} present in source table ({1})"
            .format(indices, source_table))
    _assert(columns_exist_in_table(source_table, pivs),
            "Pivot: Not all columns from {0} present in source table ({1})"
            .format(pivs, source_table))
    _assert(columns_exist_in_table(source_table, vals),
            "Pivot: Not all columns from {0} present in source table ({1})"
            .format(vals, source_table))
#------------------------------------------------------------------------------

def pivot_help(schema_madlib, message, **kwargs):
    """
    Help function for pivot

    Args:
        @param schema_madlib
        @param message: string, Help message string
        @param kwargs

    Returns:
        String. Help/usage information
    """
    if not message:
        help_string = """
-----------------------------------------------------------------------
                            SUMMARY
-----------------------------------------------------------------------
Provide a data summarization tool that can do basic OLAP type operations on
data stored in one table and output the summarized data to a second table.
Typical operations are count, average, min, max and standard deviation, however
user defined aggregates (UDAs) are also be allowed.

For more details on function usage:
    SELECT {schema_madlib}.pivot('usage')
            """
    elif message in ['usage', 'help', '?']:
        help_string = """
-----------------------------------------------------------------------
                            USAGE
-----------------------------------------------------------------------
 SELECT {schema_madlib}.pivot(
    source_table,           -- Name of source table containing data for pivoting
    out_table,              -- Name of output table taht contains pivoted data
    index,                  -- Comma-separated columns that will form the index
                            -- of the output pivot table
    pivot_cols,             -- Comma-separated columns that will form the
                            -- columns of the output pivot table
    pivot_values            -- Comma-separated columns that contain the values
                            -- to be summarized in the output pivot table
    fill_value              -- If specified, determines how to fill NULL values
                            -- resulting from pivot operation
    keep_null               -- The flag for determining how to handle NULL
                            -- values in pivot columns
    output_col_dictionary   -- The flag for enabling the creation of the
                            -- output dictionary for shorter column names
 );

-----------------------------------------------------------------------
                            OUTPUT
-----------------------------------------------------------------------
The output table ('output_table' above) has all the columns present in index
column list, plus additional columns for each distinct value in pivot_cols.
The column name for the pivot is
set as '<pivot name>_<pivot value>'.
"""
    else:
        help_string = "No such option. Use {schema_madlib}.pivot()"

    return help_string.format(schema_madlib=schema_madlib)
# ---------------------------------------------------------------------
