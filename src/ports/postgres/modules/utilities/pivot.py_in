# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Pivoting
# The goal of the MADlib pivot function is to provide a data summarization tool
# that can do basic OLAP type operations on data stored in one table and output
# the summarized data to a second table.  Typical operations are count, average,
# min, max and standard deviation, however user defined aggregates (UDAs) are
# also be allowed.

# Please refer to the pivot.sql_in file for the documentation

"""
@file pivot.py_in

"""
import plpy
import itertools
from control import MinWarning
from utilities import _assert
from utilities import split_quoted_delimited_str
from utilities import strip_end_quotes
from utilities import extract_keyvalue_params
from validate_args import table_exists
from validate_args import columns_exist_in_table
from validate_args import table_is_empty
from validate_args import _get_table_schema_names
from validate_args import get_first_schema

m4_changequote(`<!', `!>')

def pivot(schema_madlib, source_table, out_table,
                 index, pivot_cols, pivot_values,
                 aggregate_func, fill_value=None,
                 keep_null=False, **kwargs):
    """
    Helper function that can be used to pivot tables
    Args:
        @param source_table     The original data table
        @param out_table        The output table that contains the dummy
                                variable columns
        @param index            The index columns to group by the records by
        @param pivot_cols       The columns to pivot the table
        @param pivot_values     The value columns to be summarized in the
                                pivoted table
        @param aggregate_func   The aggregate function to be applied to the
                                values
        @param fill_value       If specified, determines how to fill NULL
                                values resulting from pivot operation
        @param keep_null        The flag for determining how to handle NULL
                                values in pivot columns
    """
    """
    Assume we have the following table
        pivset( id INTEGER, piv FLOAT8, val FLOAT8 )
    where the piv column has 3 distinct values (10, 20 and 30).
    If the pivot function call is :
        SELECT madlib.pivot('pivset', 'pivout', 'id', 'piv', 'val');
    We want to construct the following sql code to pivot the table.
        CREATE TABLE pivout AS (SELECT id,
        avg(CASE WHEN "piv" = '10' THEN val ELSE NULL END ) as "val_avg_piv_10",
        avg(CASE WHEN "piv" = '20' THEN val ELSE NULL END ) as "val_avg_piv_20",
        avg(CASE WHEN "piv" = '30' THEN val ELSE NULL END ) as "val_avg_piv_30"
        FROM pivset GROUP BY id ORDER BY id)

    """
    indices = split_quoted_delimited_str(index)
    pcols = split_quoted_delimited_str(pivot_cols)
    pvals = split_quoted_delimited_str(pivot_values)
    validate_pivot_coding(source_table, out_table, indices, pcols, pvals)

    # Strip end quotes from pivot columns
    pcols = [strip_end_quotes(pcol.strip()) for pcol in pcols]

    # Parse the aggregate_func as a dictionary
    try:
        param_types = dict.fromkeys(pvals, list)
        param_types['__madlib_def_pval__'] = list
        agg_dict = extract_keyvalue_params(aggregate_func,param_types)
    except KeyError, e:
        with MinWarning("warning"):
            plpy.warning("Pivot: Not all columns from '{aggregate_func}' present"
            " in '{pivot_values}'".format(**locals()))
            raise

    # If the dictionary is empty, parse it as a list
    agg_set = split_quoted_delimited_str(aggregate_func) if len(agg_dict) < 1 \
         else []
    # If the list is empty set 'avg' as default
    agg_dict['__madlib_def_agg__'] = ['avg'] if len(agg_set) < 1 else agg_set

    # Find the distinct values of pivot_cols
    # Note that the distinct values are appended in order of users list
    # This ordering is important when we access pivot_comb entries
    distinct_str = ["SELECT "]
    distinct_str.append(
        ', '.join("array_agg(DISTINCT {pcol}) AS {pcol}_values".
            format(pcol=pcol) for pcol in pcols))
    distinct_str.append(" FROM " + source_table)
    distinct_values = plpy.execute(''.join(distinct_str))

    # Collect the distinc values for every pivot column
    pcol_distinct_values = []
    for pcol in pcols:
        # Read the distinct values for this pcol
        pcol_tmp = [item for item in
            distinct_values[0][pcol+"_values"]]
        # Remove null values if keep null is not true
        if not keep_null:
            pcol_tmp = filter(None,pcol_tmp)
        pcol_distinct_values.append(pcol_tmp)

    # Create the combination of every possible pivot column
    # Assume piv and piv2 are pivot columns. piv=(1,2) and piv2=(3,4,5)
    # pivot_comb = ((1,3),(1,4),(1,5),(2,3),(2,4),(2,5))
    pivot_comb = list(itertools.product(*pcol_distinct_values))

    #Prepare the wrapper for fill value
    fill_str_begin = ""
    fill_str_end = ""
    if fill_value is not None:
        fill_str_begin = " COALESCE("
        fill_str_end = ", "+fill_value+" ) "

    new_col_names =[]
    sql_list = ["CREATE TABLE " + out_table + " AS (SELECT " + index]

    # For every value column pval
    for pval in pvals:
        pval_no_quotes = strip_end_quotes(pval.strip())

        # If this pval has an entry in the dictionary use the assigned
        # aggregate function, otherwise use the default
        try:
            agg_func = agg_dict[pval] if len(agg_dict) > 1 else \
                       agg_dict['__madlib_def_agg__']
        except KeyError, e:
            with MinWarning("warning"):
                plpy.warning("Pivot: Pivot column '{pval}' does not have an "
                "assigned aggregate function in '{aggregate_func}'".
                    format(**locals()))
                raise

        for agg in agg_func:

            # For every pivot value combination
            for comb in pivot_comb:

                pivot_str_begin=[]
                pivot_str_end=["\"{pval}_{agg}".
                    format(pval=pval_no_quotes,agg=agg)]

                # For every pivot column in a given combination
                for counter, pcol in enumerate(pcols):
                    # If we encounter a NULL value that means it is not filtered
                    # because of keep_null. Use "IS NULL" for comparison
                    if comb[counter] is None:
                        pivot_str_begin.append(" \"{pcol}\" IS NULL".
                            format(pcol=pcol))
                        # Naming the output column
                        pivot_str_end.append("_{pcol}_null".
                            format(pcol=pcol))
                    else:
                        pivot_str_begin.append(" \"{pcol}\" = '{value}'".
                            format(pcol=pcol, value = comb[counter]))
                        pivot_str_end.append("_{pcol}_{value}".
                            format(pcol=pcol, value = comb[counter]))
                pivot_str_end.append("\"")

                # Collecting the whole sql query
                # Please refer to the earlier comment for a sample output
                pivot_str=("{fill_str_begin} {agg}(CASE WHEN {pivot_begin}"
                " THEN {pval} ELSE NULL END) {fill_str_end} as {pivot_end}".
                format(fill_str_begin=fill_str_begin,
                       fill_str_end=fill_str_end,
                       pval=pval_no_quotes, agg=agg,
                       pivot_begin=' AND '.join(pivot_str_begin),
                       pivot_end=''.join(pivot_str_end)))
                sql_list.append(","+pivot_str)

    sql_list.append(" FROM " + source_table +
                    " GROUP BY " + index + " ORDER BY " + index + ") ")

    try:
        plpy.execute(''.join(sql_list))
    except plpy.SPIError:
        # Warn user if the number of columns is over 1000 for the output table
        with MinWarning("warning"):

            # The column options from value columns and aggregates
            # If there is a dict. of aggregates count them
            if len(agg_dict) > 1:
                col_va_coef=sum([len(item) for item in agg_dict.values()]) - 1
            # If there is a list of aggregates
            # multiply the number of aggregates with the number of value columns
            else:
                col_va_coef=len(agg_dict['__madlib_def_agg__'])*len(pvals)

            # Multiply the va coef. with the number of pivot combinations
            if (col_va_coef*len(pivot_comb)) > 1000:
                plpy.warning("Pivot: Too many distinct values for pivoting! "
                    "The execution may fail due to too many columns in the "
                    "output table.")
        raise

    return None
#------------------------------------------------------------------------------

def validate_pivot_coding(source_table, out_table, indices, pivs, vals):
    """
    Args:
        @param source_table The original data table
        @param out_table    The output table that will contain dummy columns
        @param indices      An array of index column names
        @param cols         An array of categorical column names
    """
    _assert(out_table and
            out_table.strip().lower() not in ('null', ''),
            "Pivot: Invalid output table name!")
    _assert(not table_exists(out_table),
            "Pivot: Output table already exists!")
    _assert(source_table and source_table.strip().lower() not in ('null', ''),
            "Pivot: Invalid data table name!")
    _assert(table_exists(source_table),
            "Pivot: Data table ({0}) is missing!". format(source_table))
    _assert(not table_is_empty(source_table),
            "Pivot: Data table ({0}) is empty!". format(source_table))

    _assert(indices and indices not in ('null', ''),
            "Pivot: Invalid index column!")
    _assert(pivs and pivs not in ('null', ''),
            "Pivot: Invalid pivot column!")
    _assert(vals and vals not in ('null', ''),
            "Pivot: Invalid value column!")

    _assert(columns_exist_in_table(source_table, indices),
            "Pivot: Not all columns from {0} present in source table ({1})"
            .format(indices, source_table))
    _assert(columns_exist_in_table(source_table, pivs),
            "Pivot: Not all columns from {0} present in source table ({1})"
            .format(pivs, source_table))
    _assert(columns_exist_in_table(source_table, vals),
            "Pivot: Not all columns from {0} present in source table ({1})"
            .format(vals, source_table))
#------------------------------------------------------------------------------

def pivot_help(schema_madlib, message, **kwargs):
    """
    Help function for pivot

    Args:
        @param schema_madlib
        @param message: string, Help message string
        @param kwargs

    Returns:
        String. Help/usage information
    """
    if not message:
        help_string = """
-----------------------------------------------------------------------
                            SUMMARY
-----------------------------------------------------------------------
Provide a data summarization tool that can do basic OLAP type operations on
data stored in one table and output the summarized data to a second table.
Typical operations are count, average, min, max and standard deviation, however
user defined aggregates (UDAs) are also be allowed.

For more details on function usage:
    SELECT {schema_madlib}.pivot('usage')
            """
    elif message in ['usage', 'help', '?']:
        help_string = """
-----------------------------------------------------------------------
                            USAGE
-----------------------------------------------------------------------
 SELECT {schema_madlib}.pivot(
    source_table,       -- Name of source table containing data for pivoting
    out_table,          -- Name of output table taht contains pivoted data
    index,              -- Comma-separated columns that will form the index of
                        -- the output pivot table
    pivot_cols,         -- Comma-separated columns that will form the columns
                        -- of the output pivot table
    pivot_values       -- Comma-separated columns that contain the values to
                        -- be summarized in the output pivot table
 );

-----------------------------------------------------------------------
                            OUTPUT
-----------------------------------------------------------------------
The output table ('output_table' above) has all the columns present in index
column list, plus additional columns for each distinct value in pivot_cols.
The column name for the pivot is
set as '<pivot name>_<pivot value>'.
"""
    else:
        help_string = "No such option. Use {schema_madlib}.pivot()"

    return help_string.format(schema_madlib=schema_madlib)
# ---------------------------------------------------------------------
