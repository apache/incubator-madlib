"""
@file in_mem_group_control.py_in

@brief in-memory grouping controller classes
"""

import plpy
from control import MinWarning
from utilities import unique_string
from collections import namedtuple

def _flatten(l, no=False):
    if no:
        return l
    if l is None or not l:
        return []
    if all(map(lambda x: x is None, l)):
        return []
    return [s for x in l for s in x]



class GroupIterationController:
    """
    @brief Abstraction for implementing in-memory iteration controller for
    SQL aggregate with STYPE=madlib.bytea8 (e.g. DynamicStruct) in PL/Python

    """

    def __init__(self, arg_dict):
        """
        arg_dict: Dictionary containing arguments to be defined by the calling function:
            Necessary:
                state_type: Type of the transition state
                            (can be double precision[] or <schema_madlib>.bytea8)
                col_dep_var: Name of the dependent column name
                col_ind_var: Name of the independent column name
            Optional:
                col_n_tuples: Name of the column containing count of tuples.
                              Set to a unique string if not defined
        """
        self.schema_madlib = arg_dict['schema_madlib']
        self.in_with = False
        self.iteration = -1
        self.is_group_null = True if arg_dict["grouping_col"] is None else False
        self.kwargs = dict(arg_dict)
        self.kwargs.update(
            state_type=arg_dict.get('state_type', 'double precision[]').format(**arg_dict),
            col_grp_null=unique_string(desp='col_grp_null'),
            col_n_tuples=self.kwargs.get('col_n_tuples', 
                                         unique_string(desp='col_n_tuples')),
            col_grp_key=self.kwargs.get('col_grp_key', 
                                        unique_string(desp='col_grp_key')),
            grouping_col=("NULL" 
                          if arg_dict["grouping_col"] is None
                          else arg_dict["grouping_col"]),
            )
        self.grp_to_n_tuples = {}
        self.new_states = {}
        self.old_states = {}
        self.finished_states = {}
        self.failed_grp_keys = []

        self.is_state_type_bytea8 = False
        if self.kwargs['state_type'] == "{0}.bytea8".format(self.schema_madlib):
            self.is_state_type_bytea8 = True
        elif (self.kwargs['state_type'].lower() == "double precision[]" or
                self.kwargs['state_type'].lower() == "float8[]"):
            self.is_state_type_bytea8 = False
        else:
            plpy.error("Internal error: unexpected state type!")

        self.group_param = self._init_group_param()


    def _init_group_param(self):
        _grp_key = ("array_to_string(ARRAY[{grouping_str}], ',')"
                    .format(grouping_str=self.kwargs['grouping_str']))
        _select_rel_state = ("SELECT "
                             "grp_key AS {col_grp_key},"
                             "state AS {col_grp_state} " 
                             "FROM {schema_madlib}._gen_state($1, NULL, $2)"
                             .format(**self.kwargs))
        _select_n_tuples = ("SELECT "
                            "unnest($3) AS {col_grp_key}, "
                            "unnest($4) AS {col_n_tuples}"
                            .format(**self.kwargs))
        _using_str="ON TRUE"
        _grouped_state_type="float8[]"
        _groupby_str=""
        if not self.is_group_null:
            _groupby_str = "GROUP BY {grouping_col}, {col_grp_key}".format(
                **self.kwargs) 
            _using_str = "USING ({col_grp_key})".format(**self.kwargs) 
            _grp_key = self.kwargs['col_grp_key']
        if self.is_state_type_bytea8:
            _select_rel_state = ("SELECT "
                                 "unnest($1) AS {col_grp_key}, "
                                 "unnest($2) AS {col_grp_state}"
                                 "".format(**self.kwargs))
            _grouped_state_type = "{schema_madlib}.bytea8[]".format(**self.kwargs)
        GroupParam = namedtuple('GroupParam', 
                                'groupby_str, using_str,'
                                'select_rel_state,grouped_state_type,'
                                'grp_key, select_n_tuples')
        return GroupParam(groupby_str=_groupby_str, 
                          using_str=_using_str,
                          select_rel_state=_select_rel_state,
                          grp_key=_grp_key,
                          select_n_tuples=_select_n_tuples,
                          grouped_state_type=_grouped_state_type)


    def __enter__(self):
        verbosity_level = self.kwargs.get('verbosity_level', 'warning')
        with MinWarning(verbosity_level):
            ############################
            # create state table
            # currently assuming that groups is passed as a valid array
            group_col = ("NULL::integer as {col_grp_null}" if self.is_group_null
                         else "{grouping_col}").format(**self.kwargs)
            groupby_str = ("{col_grp_null}" if self.is_group_null
                           else "{grouping_col}").format(**self.kwargs)
            plpy.execute("""
                DROP TABLE IF EXISTS {rel_state};
                CREATE TEMPORARY TABLE {rel_state} AS (
                    SELECT
                        array_to_string(ARRAY[{grouping_str}], ',') AS {col_grp_key},
                        0::integer                                  AS {col_grp_iteration},
                        NULL::{state_type}                          AS {col_grp_state},
                        count(*)                                    AS {col_n_tuples},
                        {group_col}
                    FROM {rel_source}
                    WHERE ({col_dep_var}) IS NOT NULL
                      AND NOT {schema_madlib}.array_contains_null({col_ind_var})
                    GROUP BY {groupby_str}
                );
                """.format(group_col=group_col,
                           groupby_str=groupby_str,
                           **self.kwargs))

            ############################
            # checking null in group values
            # We cannot allow NULL due to array_to_string cannot handle it well.
            if not self.is_group_null:
                null_test = (" OR ".join([g.strip() + " is NULL" for g in
                             self.kwargs['grouping_col'].split(",")]))
                null_count = plpy.execute("""
                    SELECT count(*) FROM {rel_state} WHERE {null_test}
                    """.format(null_test=null_test,
                               rel_state=self.kwargs['rel_state']))[0]['count']
                if null_count != 0:
                    plpy.error("Grouping error: at least one of the grouping "
                               "columns contains NULL values! Please filter "
                               "out those NULL values.")

            ############################
            # initialize states
            rel_state_str = self.kwargs['rel_state']
            col_grp_key = self.kwargs['col_grp_key']
            col_n_tuples = self.kwargs['col_n_tuples']
            ret_states = plpy.execute("SELECT * FROM " + rel_state_str)
            for state in ret_states:
                self.new_states[state[col_grp_key]] = None
                self.grp_to_n_tuples[state[col_grp_key]] = long(state[col_n_tuples])

        self.in_with = True
        return self

    def info(self):
        """ Logging intermediate state information """
        if not self.kwargs['verbose']:
            return
        group_param = self.group_param
        plan = plpy.prepare(
            """
            SELECT 
                {col_grp_key}                   AS group,
                (result).loss                   AS loss,
                (result).norm_of_gradient       AS norm_of_gradient
            FROM (
                SELECT 
                    {schema_madlib}.internal_linear_svm_igd_result({col_grp_state}) 
                    AS result,
                    {col_grp_key} 
                FROM ( {select_rel_state} ) AS _rel_state
            ) subq
            """.format(select_rel_state=group_param.select_rel_state,
                       **self.kwargs),
            ["text[]", group_param.grouped_state_type])

        if self.is_state_type_bytea8:
            res_tuples = plpy.execute(plan, [self.new_states.keys(),
                                            self.new_states.values()])
        else:
            flatten_agg_states = [c for state in self.new_states.values() for c in state]
            res_tuples = plpy.execute(plan, [self.new_states.keys(),
                                            flatten_agg_states])
        for t in res_tuples:
            grp, loss, normg = t['group'], t['loss'], t['norm_of_gradient']
            iteration = self.iteration
            output_str = "DEBUG: \
                    grp = {grp:10s}, \
                    iter = {iteration:5d}, \
                    loss = {loss:.5e}, \
                    |gradient| = {normg:.5e}, \
                    stepsize = {stepsize:.5e}" 
            plpy.notice(output_str.format(
                        grp=grp, iteration=iteration,
                        loss=loss, normg=normg, 
                        **self.kwargs))



    def final(self):
        """ Store the final converged state to a table for output """
        group_param = self.group_param
        insert_sql = """
            INSERT INTO {rel_state}
            SELECT
                {col_grp_key},
                {iteration}::int,
                {col_grp_state},
                {col_n_tuples}::bigint,
                {grouping_col}
            FROM (
                    SELECT {grouping_col}, {col_grp_key}
                    FROM {rel_state}
                ) AS _src
            JOIN ( {select_rel_state} ) AS _rel_state
            USING ({col_grp_key})
            JOIN ( {select_n_tuples} ) AS _rel_n_tuples
            USING ({col_grp_key})
            """.format(
                iteration=self.iteration,
                select_rel_state=group_param.select_rel_state,
                select_n_tuples=group_param.select_n_tuples,
                **self.kwargs)
        insert_plan = plpy.prepare(insert_sql,
                                   ["text[]", group_param.grouped_state_type,
                                    "text[]", "bigint[]"])

        if self.is_state_type_bytea8:
            insert_values = self.finished_states.values()

        else:
            insert_values = [c for state in self.finished_states.values()
                             for c in state]
        plpy.execute(insert_plan, [self.finished_states.keys(),
                                   insert_values,
                                   self.grp_to_n_tuples.keys(),
                                   self.grp_to_n_tuples.values()])
        plpy.execute(insert_plan, [self.failed_grp_keys,
                                   [],
                                   self.grp_to_n_tuples.keys(),
                                   self.grp_to_n_tuples.values()])

    def __exit__(self, type, value, tb):
        self.in_with = False

    def test(self, condition):
        """
        Return True if the given expression is TRUE for all in-progress groups.
        Also returns True if there are no groups currently in-progress.

        Evaluate the given expression for all in-progress groups.
        Move groups with expression as True from self.new_states to
        self.finished_states. The expression may depend on the current
        inter-iteration state and all arguments

        @param condition SQL boolean expression. The
            following names are defined and can be used in the condition:
            - \c _args  - The (single-row) argument table
            - \c _state - In memory inter-iteration state
        @return True if \c expression in all non-failed groups is True,
                otherwise False
        """
        if not self.new_states:
            # self.new_states can become empty if the last of the groups failed
            # in the previous update
            return True

        if self.is_state_type_bytea8:
            unnest_str_previous = "unnest($1) AS {col_grp_key}, unnest($2) AS _state_previous".format(**self.kwargs)
            unnest_str_current = "unnest($3) AS {col_grp_key}, unnest($4) AS _state_current".format(**self.kwargs)
            grouped_state_type = "{schema_madlib}.bytea8[]".format(**self.kwargs)
        else:
            unnest_str_previous = "grp_key AS {col_grp_key}, state AS _state_previous FROM {schema_madlib}._gen_state($1, NULL, $2)".format(**self.kwargs)
            unnest_str_current = "grp_key AS {col_grp_key}, state AS _state_current FROM {schema_madlib}._gen_state($3, NULL, $4)".format(**self.kwargs)
            grouped_state_type = "float8[]"

        condition = condition.format(iteration=self.iteration, **self.kwargs)
        eval_plan = plpy.prepare("""
            SELECT
                CAST(({condition}) AS BOOLEAN) AS _expression,
                {col_grp_key}
            FROM
            (
                (
                    SELECT {unnest_str_previous}
                ) sub1
                JOIN
                (
                    SELECT {unnest_str_current}
                ) sub2
                USING ({col_grp_key})
            ) subq1
            """.format(condition=condition,
                       unnest_str_current=unnest_str_current,
                       unnest_str_previous=unnest_str_previous, **self.kwargs),
            ["text[]", grouped_state_type] * 2)

        if self.is_state_type_bytea8:
            ret_tuples = plpy.execute(eval_plan,
                                      [self.old_states.keys(),
                                       self.old_states.values(),
                                       self.new_states.keys(),
                                       self.new_states.values()])
        else:
            if self.iteration == 1:
                flatten_agg_states_old = []
            else:
                flatten_agg_states_old = [c for state in self.old_states.values() for c in state]
            ret_tuples = plpy.execute(eval_plan,
                                      [self.old_states.keys(),
                                       flatten_agg_states_old,
                                       self.new_states.keys(),
                                       [c for state in self.new_states.values() for c in state]])

        self.old_states = {}
        for t in ret_tuples:
            if t['_expression']:
                k = t[self.kwargs['col_grp_key']]
                self.finished_states[k] = self.new_states[k]
                del self.new_states[k]

        return len(self.new_states) == 0

    def update(self, newState, **updateKwargs):
        """
        Update the inter-iteration state

        @param newState SQL expression of (or returning) type
            <tt>state_type.kwargs.state_type</tt>. The
            following names are defined and can be used in the condition:
            - \c _args  - The (single-row) argument table
            - \c _state - In memory inter-iteration state
            .
            Note that <tt>{iteration}</tt> will still be the current iteration.
            For instance, it could be used in the expression as a WHERE
            condition: <tt>[...] WHERE _state._iteration = {iteration}</tt>

        This updates the current inter-iteration state to the result of
        evaluating \c newState. If <tt>self.truncAfterIteration</tt> is true,
        this will replace the old state, otherwise the history of all old states
        is kept.
        """

        newState = newState.format(**self.kwargs)
        self.iteration = self.iteration + 1
        
        group_param = self.group_param
        update_plan = plpy.prepare(
            """
            SELECT
                {_grp_key} AS {col_grp_key},
                {grouping_col},
                {iteration} AS {col_grp_iteration},
                ({newState}) AS {col_grp_state}
            FROM (
                SELECT
                    *,
                    array_to_string(ARRAY[{grouping_str}], ',') AS {col_grp_key}
                FROM {rel_source}
            ) AS _src
            JOIN ( {select_rel_state} ) AS {rel_state}
            {using_str}
            JOIN ( {select_n_tuples} ) AS _rel_n_tuples
            {using_str}
            {groupby_str}
            """.format(
                newState=newState,
                iteration=self.iteration,
                using_str=group_param.using_str,
                groupby_str=group_param.groupby_str,
                _grp_key=group_param.grp_key,
                select_rel_state=group_param.select_rel_state,
                select_n_tuples=group_param.select_n_tuples,
                **self.kwargs),
            ["text[]", group_param.grouped_state_type, "text[]", "integer[]"])

        if self.is_state_type_bytea8:
            res_tuples = plpy.execute(update_plan, [self.new_states.keys(),
                                                    self.new_states.values(),
                                                    self.grp_to_n_tuples.keys(),
                                                    self.grp_to_n_tuples.values()])
        else:
            if self.iteration == 1:
                flatten_agg_states = []
            else:
                flatten_agg_states = [c for state in self.new_states.values() for c in state]
            res_tuples = plpy.execute(update_plan, [self.new_states.keys(),
                                                    flatten_agg_states,
                                                    self.grp_to_n_tuples.keys(),
                                                    self.grp_to_n_tuples.values()])

        # self.old_states = self.new_states
        self.old_states.update(self.new_states)
        col_grp_state = self.kwargs['col_grp_state']
        col_grp_key = self.kwargs['col_grp_key']
        for t in res_tuples:
            _grp_key, _grp_state = t[col_grp_key], t[col_grp_state]
            if _grp_state is None: self.failed_grp_keys.append(_grp_key)
            else: self.new_states[_grp_key] = _grp_state
